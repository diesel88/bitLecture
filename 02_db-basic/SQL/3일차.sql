SELECT DEPARTMENT_ID, DEPARTMENT_NAME
  FROM DEPARTMENTS;
  
SELECT DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE LAST_NAME = 'hunold';  --60
 
SELECT DEPARTMENT_NAME
  FROM DEPARTMENTS
 WHERE DEPARTMENT_ID = 60;
 
-- Hunold 60 IT
-- 테이블 별칭(ALIAS) 사용
SELECT E.LAST_NAME, 
	   E.DEPARTMENT_ID,
	   D.DEPARTMENT_NAME
  FROM EMPLOYEES E, 
       DEPARTMENTS D
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;	-- 증거 조건

-- 각 사원의 직무에 따른 최소 급여와 최대 급여를
-- 화면에 출력한다.
-- (이름, 직무명, 최소, 최대 급여)
 -- EQUI JOIN ( = )
SELECT E.LAST_NAME, J.JOB_TITLE, J.MIN_SALARY, J.MAX_SALARY
  FROM EMPLOYEES E,
       JOBS J
 WHERE E.JOB_ID = J.JOB_ID;
 
 -- CANADA 에 근무하는 사원의
 -- 지역명, 부서명, 사원명 출력하시오
SELECT L.CITY, D.DEPARTMENT_NAME, E.LAST_NAME
  FROM EMPLOYEES E,
  	   DEPARTMENTS D,
  	   LOCATIONS L,
  	   COUNTRIES C
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
    AND D.LOCATION_ID = L.LOCATION_ID
    AND L.COUNTRY_ID = C.COUNTRY_ID
    AND C.COUNTRY_NAME = 'Canada';
    
SELECT *
  FROM SALGRADE;

SELECT LAST_NAME, SALARY
  FROM EMPLOYEES;

-- NON EQUI JOIN ( = 이외의 연산자 사용 )
-- 사원의 이름, 급여, 급여 등급 출력
SELECT E.LAST_NAME, E.SALARY, S.GRADE
  FROM EMPLOYEES E, SALGRADE S
 WHERE E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL;
 
-- SELF JOIN ( 물리적 테이블은 하나.. 논리적 테이블 2개이상)

SELECT EMPLOYEE_ID, LAST_NAME, MANAGER_ID
  FROM EMPLOYEES;
  
-- 사원번호 사원명 관리자번호 관리자명
SELECT E.EMPLOYEE_ID, E.LAST_NAME, M.EMPLOYEE_ID, M.LAST_NAME
  FROM EMPLOYEES E, EMPLOYEES M
 WHERE E.MANAGER_ID = M.EMPLOYEE_ID
 ORDER BY E.EMPLOYEE_ID;
 
 
-- OUTER JOIN ( 조인조건을 만족하지 않더라도 결과에 포함)
-- (+) 결과가 모자란 쪽에 붙인다.
-- 양쪽에 같이 붙일 수 없다.
SELECT E.EMPLOYEE_ID, E.LAST_NAME, 
	   NVL(M.EMPLOYEE_ID || '', '관리자 없음'), NVL(M.LAST_NAME, '관리자 없음') LAST_NAME_1
  FROM EMPLOYEES E, EMPLOYEES M
 WHERE E.MANAGER_ID = M.EMPLOYEE_ID(+)
 ORDER BY E.EMPLOYEE_ID;
 
 
 
-- ORACLE 9I 부터 CROSS JOIN (CARTESIAN PRODUCT 대체)
SELECT E.LAST_NAME, 
	   E.DEPARTMENT_ID,
	   D.DEPARTMENT_NAME
  FROM EMPLOYEES E
 CROSS JOIN DEPARTMENTS D;
 
 -- EQUI JOIN, NONEQUI JOIN, SELF JOIN
 -- INNER JOIN ON 대체
 -- 테이블 INNER JOIN 테이블 ON 증거조건
 SELECT E.LAST_NAME, 
	   E.DEPARTMENT_ID,
	   D.DEPARTMENT_NAME
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 각 사원의 직무에 따른 최소 급여와 최대 급여를
-- 화면에 출력한다.
-- (이름, 직무명, 최소, 최대 급여)
SELECT E.LAST_NAME, J.JOB_TITLE, J.MIN_SALARY, J.MAX_SALARY
  FROM EMPLOYEES E
 INNER JOIN JOBS J
    ON E.JOB_ID = J.JOB_ID;
 
 -- CANADA 에 근무하는 사원의
 -- 지역명, 부서명, 사원명 출력하시오
SELECT L.CITY, D.DEPARTMENT_NAME, E.LAST_NAME
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L
    ON D.LOCATION_ID = L.LOCATION_ID
 INNER JOIN COUNTRIES C
    ON L.COUNTRY_ID = C.COUNTRY_ID
 WHERE C.COUNTRY_NAME = 'Canada';
    

-- NON EQUI JOIN ( = 이외의 연산자 사용 )
-- 사원의 이름, 급여, 급여 등급 출력
SELECT E.LAST_NAME, E.SALARY, S.GRADE
  FROM EMPLOYEES E
 INNER JOIN SALGRADE S
    ON E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL;
 
-- SELF JOIN ( 물리적 테이블은 하나.. 논리적 테이블 2개이상)

SELECT EMPLOYEE_ID, LAST_NAME, MANAGER_ID
  FROM EMPLOYEES;
  
-- 사원번호 사원명 관리자번호 관리자명
SELECT E.EMPLOYEE_ID, E.LAST_NAME, M.EMPLOYEE_ID, M.LAST_NAME
  FROM EMPLOYEES E
 INNER JOIN EMPLOYEES M
    ON E.MANAGER_ID = M.EMPLOYEE_ID
 ORDER BY E.EMPLOYEE_ID;
 
 
-- OUTER JOIN ( 조인조건을 만족하지 않더라도 결과에 포함)
-- (FULL | LEFT | RIGHT) OUTER JOIN
SELECT E.EMPLOYEE_ID, E.LAST_NAME, 
	   NVL(M.EMPLOYEE_ID || '', '관리자 없음'), NVL(M.LAST_NAME, '관리자 없음') LAST_NAME_1
  FROM EMPLOYEES E
  LEFT OUTER JOIN EMPLOYEES M
 	ON E.MANAGER_ID = M.EMPLOYEE_ID
 ORDER BY E.EMPLOYEE_ID;

----------------------------------------
-- SET 연산자
----------------------------------------
-- 양쪽 데이터 모두 출력
-- 중복된 데이터는 한번만
 SELECT *
  FROM TC_SETA
 UNION
SELECT * 
  FROM TC_SETB;

SELECT *
  FROM TC_SETA
 UNION ALL
SELECT * 
  FROM TC_SETB;

-- 양쪽 중복된 데이터만 출력
SELECT *
  FROM TC_SETA
 INTERSECT
SELECT * 
  FROM TC_SETB;
  
 -- 차집합
SELECT *
  FROM TC_SETA
 MINUS
SELECT * 
  FROM TC_SETB;
  
SELECT LAST_NAME
  FROM EMPLOYEES
 UNION ALL
SELECT DEPARTMENT_NAME
  FROM DEPARTMENTS;

-- 주의 1. 컬럼의 수가 동일해야 한다.
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 UNION ALL
SELECT DEPARTMENT_NAME
  FROM DEPARTMENTS;

-- 주의 2. 대응되는 컬럼의 데이터 타입은 동일해야 한다.
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 UNION ALL
SELECT DEPARTMENT_ID, DEPARTMENT_NAME
  FROM DEPARTMENTS;

-- 주의 3. ORDER BY 절은 맨 마지막에 위치해야 함
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 ORDER BY SALARY
 UNION ALL
SELECT DEPARTMENT_NAME, DEPARTMENT_ID 
  FROM DEPARTMENTS;

-- 컬럼의 이름은 처음 실행된 SELECT 문이 사용
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 UNION ALL
SELECT DEPARTMENT_NAME, DEPARTMENT_ID 
  FROM DEPARTMENTS
 ORDER BY SALARY;
 
 --------------------------------------
 -- 서브쿼리(SUBQUERY)
 --------------------------------------
 -- Chen의 부서번호
 SELECT DEPARTMENT_ID 
   FROM EMPLOYEES
  WHERE LAST_NAME = 'Chen';
  
-- Chen 과 같은 부서에 근무하는 사원의 정보 출력

SELECT *
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 100;

 -- (서브쿼리)
 -- Single Row SubQuery
 -- : 서브쿼리의 결과 행이 하나인 것
 SELECT *
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID 
						   FROM EMPLOYEES
						  WHERE LAST_NAME = 'Chen');
-- King 과 같은 부서에 근무하는 사원의 정보 출력
-- Multi Row SubQuery
-- : 서브쿼리의 결과행이 여러개인 것
-- : IN, ANY, ALL
SELECT *
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
						   FROM EMPLOYEES
						  WHERE LAST_NAME = 'King');
-- 2개의 행						  
SELECT DEPARTMENT_ID 
  FROM EMPLOYEES
 WHERE LAST_NAME = 'King';
 
 
-- 30부서의 사원들이 받는 급여보다 급여를 많이 
-- 받는 사원의 정보를 출력
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 WHERE SALARY >ALL (SELECT SALARY
 				   		FROM EMPLOYEES
 				  		WHERE DEPARTMENT_ID = 30);

SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 WHERE SALARY <ANY (SELECT SALARY
 				   		FROM EMPLOYEES
 				  		WHERE DEPARTMENT_ID = 30);
SELECT LAST_NAME, SALARY
  FROM EMPLOYEES
 WHERE SALARY < (SELECT MAX(SALARY)
 				   		FROM EMPLOYEES
 				  		WHERE DEPARTMENT_ID = 30);
 				  		
-- 각 부서에서 가장 작은 급여를 받는 사원 정보 출력
SELECT LAST_NAME, SALARY 
  FROM EMPLOYEES
  WHERE SALARY IN (부서에서 가장 작은 급여);

-- MULTI COLUMN SUBQUERY
-- : 서브쿼리의 실행된 컬럼의 개수가 여러개
SELECT LAST_NAME, SALARY 
  FROM EMPLOYEES
  WHERE (DEPARTMENT_ID, SALARY) IN (SELECT DEPARTMENT_ID, MIN(SALARY)
  					FROM EMPLOYEES
  				   GROUP BY DEPARTMENT_ID);
  				   
-- 서브쿼리가 자주 사용되는 위치
-- INSERT, UPDATE, DELETE
INSERT INTO TB_BOARD(
	NO, TITLE, WRITER, CONTENT)
) VALUES (
	(SELECT NVL(MAX(NO)), 0) +1 FROM TB_BOARD),
	'aa','bb','cc'
);

-- SELECT
SELECT E.LAST_NAME, E.DEPARTMENT_ID, 
	   D. DEPARTMENT_NAME
  FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
-- SELECT SUBQUERY
SELECT E.LAST_NAME, E.DEPARTMENT_ID, 
	   (SELECT DEPARTMENT_NAME 
	   	  FROM DEPARTMENTS
	   	 WHERE DEPARTMENT_ID = E.DEPARTMENT_ID)
	   AS DEPT_NAME
  FROM EMPLOYEES E; 				
  
-- FROM 절의 서브쿼리
-- INLINE VIEW
SELECT * 
  FROM (SELECT EMPLOYEE_ID EID, SALARY SAL
          FROM EMPLOYEES
         ORDER BY SAL) A;

-- 위의 쿼리를 조인으로 변경한다.
SELECT E.LAST_NAME, E.SALARY 
  FROM EMPLOYEES A,
  		(SELECT DEPARTMENT_ID, MIN(SALARY) SAL
  					FROM EMPLOYEES
  				   GROUP BY DEPARTMENT_ID) B
  WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND A.SALARY = B.SAL;

SELECT E.LAST_NAME, E.SALARY 
  FROM EMPLOYEES A
 INNER JOIN (SELECT DEPARTMENT_ID, MIN(SALARY) SAL
  					FROM EMPLOYEES
  				   GROUP BY DEPARTMENT_ID) B
     ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
    AND A.SALARY = B.SAL;
  
----------------------------------------------
-- rownum 의 이해
----------------------------------------------
-- 급여를 많이 받는 상위 5명의 정보를 출력

-- 순서대로 앞에서 5명을 추출한뒤
-- 추출된 사원의 급여순으로 정렬
SELECT ROWNUM, LAST_NAME, SALARY
  FROM EMPLOYEES
 WHERE RONUM < 6
 ORDER BY SALARY DESC;
-- 출력안됨
SELECT ROWNUM, LAST_NAME, SALARY
  FROM EMPLOYEES
 WHERE ROWNUM = 2;
 
 SELECT ROWNUM, LAST_NAME, SALARY
  FROM EMPLOYEES
 ORDER BY SALARY DESC
 WHERE RONUM < 6;
 
SELECT ROWNUM, A.LAST_NAME, A.SALARY
  FROM (SELECT *
  		FROM EMPLOYEES
 		ORDER BY SALARY DESC) A
 WHERE ROWNUM < 6;

SELECT ROWNUM RNUM, A.LAST_NAME, A.SALARY
  FROM (SELECT *
  		FROM EMPLOYEES
 		ORDER BY SALARY DESC) A;
 		
-- 페이징
 SELECT * 
   FROM (
    SELECT ROWNUM RNUM, A.LAST_NAME, A.SALARY
  		FROM ( SELECT *
  				FROM EMPLOYEES
  				ORDER BY SALARY DESC
 				) A
 		)
 WHERE RNUM BETWEEN 5 AND 8;
 
-- 테이블 생성시 서브쿼리 활용하기
CREATE TABLE EMPLOYEES_COPY
AS
SELECT * FROM EMPLOYEES;

DROP TABLE EMPLOYEES_COPY;

SELECT * FROM EMPLOYEES_COPY;

-- 테이블 구조만 복사
CREATE TABLE EMPLOYEES_COPY
AS
SELECT * FROM EMPLOYEES
WHERE 1 != 1;

-- 테이블은 존재하는 상태에서 데이터를 복사
INSERT INTO EMPLOYEES_COPY
SELECT * FROM EMPLOYEES;

INSERT INTO EMPLOYEES_COPY(EMPLOYEE_ID)
SELECT EMPLOYEE_ID FROM EMPLOYEES;

------------------------------------
-- ALTER : 테이블 변경
-- 컬럼 추가, 컬럼 삭제, 
-- 컬럼 변경(타입, 크기, DEFAULT, NOT NULL)
-- 추가 : ADD, 삭제 : DROP, 변경 : MODIFY
------------------------------------
ALTER TABLE 테이블명
ADD (컬럼...);

ALTER TABLE 테이블명
DROP (컬럼);

ALTER TABLE 테이블명
MODIFY (컬럼);

9I부터 컬럼의 이름 변경 가능
ALTER TABLE 테이블명
RENAME COLUMN A TO B;


CREATE TABLE TB_ALTER (
	NAME VARCHAR2(10),
	AGE VARCHAR2(3)
);

-- 컬럼 추가
ALTER TABLE TB_ALTER
ADD (EMAIL VARCHAR2(20));

SELECT * FROM TB_ALTER;
DESC TB_ALTER;

-- 컬럼 이름 변경
ALTER TABLE TB_ALTER
RENAME COLUMN NAME TO NAME;

-- 컬럼 삭제
ALTER TABLE TB_ALTER
DROP (EMAIL);

-- 컬럼 변경
ALTER TABLE TB_ALTER
MODIFY (AGE NUMBER(3));

